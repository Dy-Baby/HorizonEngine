#include "../BindlessCommon.hsf"
#include "HybridRenderPipelineCommon.hsf"

#define RAY_TRACING_SHADOWS_SHADER_PER_FRAME_DATA_SLOT       0
#define RAY_TRACING_SHADOWS_SHADER_TLAS_SLOT                 1
#define RAY_TRACING_SHADOWS_SHADER_DEPTH_BUFFER_SRV_SLOT     2
#define RAY_TRACING_SHADOWS_SHADER_SHADOW_MASK_UAV_SLOT      3

PerFrameData GetPerFrameData()
{
    uint bufferIndex = SHADER_ARGUMENTS_INDEX(RAY_TRACING_SHADOWS_SHADER_PER_FRAME_DATA_SLOT);
    return BindlessBuffers[(bufferIndex >> 16) & 0xffff].Load<PerFrameData>(bufferIndex & 0xffff);
}

RaytracingAccelerationStructure GetTopLevelAS()
{
	return BindlessASs[SHADER_ARGUMENTS_INDEX(RAY_TRACING_SHADOWS_SHADER_TLAS_SLOT)];
}

Texture2D GetDepthBufferSRV()
{
	return BindlessTexture2Ds[SHADER_ARGUMENTS_INDEX(RAY_TRACING_SHADOWS_SHADER_DEPTH_BUFFER_SRV_SLOT)];
}

RWTexture2D<float4> GetShadowMaskUAV()
{
	return BindlessRWTexture2Ds[SHADER_ARGUMENTS_INDEX(RAY_TRACING_SHADOWS_SHADER_SHADOW_MASK_UAV_SLOT)];
}

struct ShadowPayload
{
	bool miss;
};

[shader("raygeneration")]
void RayTracingShadowsRayGen()
{
    uint3 launchIndex = DispatchRaysIndex();
    uint3 launchSize = DispatchRaysDimensions();

    PerFrameData perFrameData = GetPerFrameData();
    Texture2D depthBuffer = GetDepthBufferSRV();
    RWTexture2D<float4> shadowMask = GetShadowMaskUAV();

    const uint2 pixelCoord = launchIndex.xy;

    // Skip background pixels
    const float depth = depthBuffer[pixelCoord].r;
    if (depth == 1.0)
    {
        shadowMask[pixelCoord] = 0.0;
        return;
    }

    // Reconstruct world position from the depth buffer
    float2 pixelCenter = pixelCoord + 0.5;
    float2 uv = pixelCenter / float2(launchSize.xy);
    float4 clipSpacePosition = float4(uv * 2.0 - 1.0, depth, 1.0);
    clipSpacePosition.y = -clipSpacePosition.y;
    float4 worldSpacePosition = mul(clipSpacePosition, perFrameData.invViewProjectionMatrix);
    worldSpacePosition /= worldSpacePosition.w;

    // float4 viewSpacePosition = mul(clipSpacePosition, perFrameData.invProjectionMatrix);
    // viewSpacePosition /= viewSpacePosition.w;
    // float3 worldSpacePosition = mul(viewSpacePosition, perFrameData.invViewMatrix).xyz;
    
    // // Initialize the Halton sequence.
    // HaltonState hState = haltonInit(hState, pixelCoord, perFrameData.frameIndex);

    // // Generate random numbers to rotate the Halton sequence.
    // uint seed = randomInit(pixelPos, launchDim.x, perFrameData.frameIndex);
    // float rnd1 = frac(haltonNext(hState) + randomNext(frameseed));
    // float rnd2 = frac(haltonNext(hState) + randomNext(frameseed));

    // // Generate a random direction based on the cone angle.
    // // The wider the cone, the softer (and noisier) the shadows are.
    // // uniformSampleCone() from [pbrt]
    // float3 rndDirection = uniformSampleCone(rnd1, rnd2, cosThetaMax);

    // Prepare a shadow ray.
    RayDesc ray;
    ray.Origin = worldSpacePosition.xyz;
    ray.Direction = normalize(float3(0.0, 0.0, 1.0));
    // ray.TMin = max(1.0, length(worldSpacePosition.xyz)) * 1e-3;
    ray.TMin = max(1.0, length(worldSpacePosition.xyz)) * 1e-2;
    ray.TMax = 100000.0;
    // ray.Direction = mul(rndDirection, createBasis(L));

    ShadowPayload payload;
    payload.miss = false;

    RaytracingAccelerationStructure topLevelAS = GetTopLevelAS();
    uint rayFlags = RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;

    TraceRay(
        topLevelAS,
        rayFlags,
        0xff,
        0,
        0,
        0,
        ray,
        payload);

    shadowMask[pixelCoord] = payload.miss ? 1.0f : 0.0f;
}

[shader("miss")]
void RayTracingShadowsMiss(inout ShadowPayload payload : SV_RayPayload)
{
    payload.miss = true;
}