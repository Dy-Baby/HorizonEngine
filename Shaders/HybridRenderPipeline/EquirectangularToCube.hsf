#include "../BindlessCommon.hsf"
#include "HybridRenderPipelineCommon.hsf"
#include "BSDFCommon.hsf"

#define EQUIRECTANGULAR_TO_CUBE_SHADER_EQUIRECTANGULAR_MAP_SRV_SLOT    0
#define EQUIRECTANGULAR_TO_CUBE_SHADER_ENVIROMENT_MAP_UAV_SLOT         1

Texture2D GetEquirectangularMapSRV()
{
    return BindlessTexture2D[SHADER_ARGUMENTS_INDEX(EQUIRECTANGULAR_TO_CUBE_SHADER_EQUIRECTANGULAR_MAP_SRV_SLOT)];
}

RWTexture2DArray<float4> GetEnviromentMapUAV()
{
	return BindlessRWTexture2DArrays[SHADER_ARGUMENTS_INDEX(EQUIRECTANGULAR_TO_CUBE_SHADER_ENVIROMENT_MAP_UAV_SLOT)];
}

[numthreads(8, 8, 1)]
void EquirectangularToCubeCS(uint3 GlobalInvocationID : SV_DispatchThreadID)
{
	RWTexture2DArray<float4> envmap = GetEnviromentMapUAV();
    uint width, height;
    iblDiffuseLut.GetDimensions(width, height);
	if (GlobalInvocationID.x >= width || GlobalInvocationID.y >= height) 
    {
        return;
    }
	uint3 coord = GlobalInvocationID;
    float2 uv = (coord.xy + 0.5) / float2(width, height);

	float3 uvw = CalculateTextureCubeUVW(uv, coord.z);
    
    // Calculate sampling coord for equirectangular texture.
	// https://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates
	float phi = atan(uvw.z, uvw.x);
	float theta = acos(uvw.y);

	Texture2D equirectangularMap = GetEquirectangularMapSRV();
    float2 equirectangularMapUV = float2(phi / (2.0 * PI) + 0.5, theta / PI);
	float4 color = equirectangularMap.SampleLevel(SAMPLER_LINEAR_WARP, equirectangularMapUV, 0);

	envmap[coord] = color;
}
