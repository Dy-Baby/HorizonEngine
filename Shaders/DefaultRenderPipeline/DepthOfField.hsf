// @see: https://blog.tuxedolabs.com/2018/05/04/bokeh-depth-of-field-in-single-pass.html

#include "PostProcessingCommon.h"

layout (location = 0) in OutputBlock Input;
layout (binding = 0) uniform sampler2D u_Texture;
layout (binding = 1) uniform sampler2D u_DepthTexture;

layout(push_constant) uniform Uniforms
{
	float Exposure;
} u_Uniforms;
const float uFar = 1000.0;

const float GOLDEN_ANGLE = 2.39996323;
const float MAX_BLUR_SIZE = 20.0;
const float RADIUS_SCALE = 0.5; // Smaller = nicer blur, larger = faster

float LinearizeDepth(float depth, float zNear, float zFar)
{
	return zNear * zFar / (zFar + depth * (zNear - zFar));
}

float GetBlurSize(float depth, float focusPoint, float focusScale)
{
	float coc = clamp((1.0 / focusPoint - 1.0 / depth) * focusScale, -1.0, 1.0);
	return abs(coc) * MAX_BLUR_SIZE;
}

[numthreads(POST_PROCESSING_THREAD_GROUP_SIZE, POST_PROCESSING_THREAD_GROUP_SIZE, 1)]
void ComputeShaderMain(uint3 GlobalInvocationID : SV_DispatchThreadID)
{
	uint width = 0;
	uint height = 0;
	finalBuffer.GetDimensions(width, height);
	if (GlobalInvocationID.x >= width || GlobalInvocationID.y >= height) 
	{
		return;
	}

	float focusPoint = LinearizeDepth(texture(u_DepthTexture, vec2(0.5f)).r, 0.1, uFar);
	float focusScale = 0.8f;
	float farPlane = ;
	vec3 color = DepthOfField(Input.TexCoord, focusPoint, focusScale, 1.0f / fTexSize);
	{
		float centerDepth = depthBuffer.Sample(samplerState, texCoord).r * farPlane;
		float centerSize = GetBlurSize(centerDepth, focusPoint, focusScale);
		float3 color = texture(colorBuffer, texCoord).rgb;
		float tot = 1.0;
		float radius = RADIUS_SCALE;
		for (float ang = 0.0; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)
		{
			float2 uv = texCoord + float2(cos(ang), sin(ang)) * uPixelSize * radius;
			float3 sampleColor = texture(uTexture, uv).rgb;
			float sampleDepth = depthBuffer.Sample(samplerState, uv).r * uFar;
			float sampleSize = GetBlurSize(sampleDepth, focusPoint, focusScale);
			if (sampleDepth > centerDepth)
			{
				sampleSize = clamp(sampleSize, 0.0, centerSize * 2.0);
			}
			float m = smoothstep(radius - 0.5, radius + 0.5, sampleSize);
			color += mix(color / tot, sampleColor, m);
			tot += 1.0;   
			radius += RADIUS_SCALE / radius;
		}
		color /= tot;
	}
	if (length(vec2(0.5) - Input.TexCoord) < 0.05)
	{
		o_Color.rgb = vec3(texture(u_DepthTexture, vec2(0.5f)).r);
	}
}
