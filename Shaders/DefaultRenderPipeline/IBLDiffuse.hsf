#include "../BindlessCommon.hsf"
#include "DefaultRenderPipelineCommon.hsf"
#include "BSDFCommon.hsf"

#define IBL_DIFFUSE_SHADER_ENVIROMENT_MAP_SRV_SLOT     0
#define IBL_DIFFUSE_SHADER_IBL_DIFFUSE_LUT_UAV_SLOT    1

const uint NUM_SAMPLES = 1024;

TextureCube GetEnviromentMapSRV()
{
	return BindlessTextureCubes[SHADER_ARGUMENTS_INDEX(IBL_DIFFUSE_SHADER_ENVIROMENT_MAP_SRV_SLOT)];
}

RWTexture2DArray<float4> GetIBLDiffuseLutUAV()
{
    return BindlessRWTexture2DArrays[SHADER_ARGUMENTS_INDEX(IBL_DIFFUSE_SHADER_IBL_DIFFUSE_LUT_UAV_SLOT)];
}

[numthreads(8, 8, 1)]
void IBLDiffuseCS(uint3 GlobalInvocationID : SV_DispatchThreadID)
{
	RWTexture2DArray<float4> iblDiffuseLut = GetIBLDiffuseLutUAV();
    uint width, height;
    iblDiffuseLut.GetDimensions(width, height);
	if (GlobalInvocationID.x >= width || GlobalInvocationID.y >= height) 
    {
        return;
    }
	uint3 coord = GlobalInvocationID.xy;
    float2 uv = (coord.xy + 0.5) / float2(width, height);

	float3 N = UVToCubemapCoord(uv, coord.z);
	float3 T = 0;
	float3 B = 0;
	GetTangentBasis(T, B, N);

	TextureCube envmap = GetEnviromentMapSRV();

	// Monte carlo integration of hemispherical irradiance
	float3 irradiance = 0;
	for (uint i = 0; i < NUM_SAMPLES; i++)
	{
		float2 Xi = Hammersley2D(i, NUM_SAMPLES);
		float3 Li = TangentToWorld(HemisphereSampleUniform(Xi), T, B, N);
		float cosLi = clamp(dot(N, Li), 0.0, 1.0);
		irradiance += envmap.SampleLevel(SAMPLER_LINEAR_WARP, Li, 0).rgb * cosLi;
	}
	// pdf = 1.0 / (2.0 * PI)
	// There is no PI here because we do not divide by PI in lighting pass
	irradiance = irradiance * 2.0 / float(NUM_SAMPLES);

	iblDiffuseLut[coord] = float4(irradiance, 1.0);
}
